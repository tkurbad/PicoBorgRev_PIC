

#include <stdio.h>
#include <stdlib.h>
#include <p24fv16km202.h>
#include <libpic30.h>
#include <time.h>



//configs
// PIC24FV16KM202 Configuration Bit Settings

//configs

#include <xc.h>

// FBS
#pragma config BWRP = OFF               // Boot Segment Write Protect (Disabled)
#pragma config BSS = OFF                // Boot segment Protect (No boot program flash segment)

// FGS
#pragma config GWRP = OFF               // General Segment Write Protect (General segment may be written)
#pragma config GCP = OFF                // General Segment Code Protect (No Protection)

// FOSCSEL
#pragma config FNOSC = FRCPLL           // Oscillator Select (Fast RC Oscillator with Postscaler and PLL Module (FRCDIV+PLL))
#pragma config SOSCSRC = DIG            // SOSC Source Type (Digital Mode for use with external source)
#pragma config LPRCSEL = HP             // LPRC Oscillator Power and Accuracy (High Power, High Accuracy Mode)
#pragma config IESO = OFF               // Internal External Switch Over bit (Internal External Switchover mode disabled (Two-speed Start-up disabled))

// FOSC
#pragma config POSCMOD = NONE           // Primary Oscillator Configuration bits (Primary oscillator disabled)
#pragma config OSCIOFNC = IO            // CLKO Enable Configuration bit (Port I/O enabled (CLKO disabled))
#pragma config POSCFREQ = HS            // Primary Oscillator Frequency Range Configuration bits (Primary oscillator/external clock input frequency greater than 8MHz)
#pragma config SOSCSEL = SOSCHP         // SOSC Power Selection Configuration bits (Secondary Oscillator configured for high-power operation)
#pragma config FCKSM = CSDCMD           // Clock Switching and Monitor Selection (Both Clock Switching and Fail-safe Clock Monitor are disabled)

// FWDT
#pragma config WDTPS = PS32768          // Watchdog Timer Postscale Select bits (1:32768)
#pragma config FWPSA = PR128            // WDT Prescaler bit (WDT prescaler ratio of 1:128)
#pragma config FWDTEN = OFF             // Watchdog Timer Enable bits (WDT disabled in hardware; SWDTEN bit disabled)
#pragma config WINDIS = ON              // Windowed Watchdog Timer Disable bit (Windowed WDT enabled)

// FPOR
#pragma config BOREN = BOR0             // Brown-out Reset Enable bits (Brown-out Reset disabled in hardware, SBOREN bit disabled)
#pragma config RETCFG = ON              //  (Retention regulator is available and controlled by RETEN bit)
#pragma config PWRTEN = OFF             // Power-up Timer Enable bit (PWRT disabled)
#pragma config I2C1SEL = PRI          // Alternate I2C1 Pin Mapping bit (Use  Alternate ASCL1/ASDA1 Pins For I2C1)
#pragma config BORV = LPBOR             // Brown-out Reset Voltage bits (Low-power Brown-Out Reset occurs around 2.0V)
#pragma config MCLRE = ON               // MCLR Pin Enable bit (RA5 input pin disabled, MCLR pin enabled)

// FICD
#pragma config ICS = PGx1               // ICD Pin Placement Select bits (EMUC/EMUD share PGC1/PGD1)            // ICD Pin Placement Select bits (EMUC/EMUD share PGC1/PGD1)



/** VARIABLES ******************************************************/



unsigned char move_array[]={0x07,0xFF,0x07, 0xFF,0x07,0xFF,0x07,0xFF};
const unsigned char i2c_address=0b11000000;
volatile unsigned char ack_failed=0;

/** PRIVATE PROTOTYPES *********************************************/
void User_Init(void);
void ssp1_Init(void);
void timer1_Init(void);


// INTERRUPT SERVICE ROUTINES********************************************



    void _ISR _T1Interrupt(void)  {
    TMR1=0;// reset timer 1
    LATBbits.LATB3=~LATBbits.LATB3;// visual reference for logic analyzer
    SSP1CON2bits.SEN = 1;       //Start Condition Enable.
    while(SSP1STATbits.I2C_START==0){
    }                           // this is just a waiting routine
    SSP1BUF=i2c_address; // write buffer
    while(SSP1STATbits.BF==0){
    }                          // this is just a waiting routine
    IFS0bits.T1IF=0; // clear interrupt flag
    }

     void _ISR _MSSP1Interrupt(void)  {
    static char count=0; // I declare my variable here as static because I dont want it to dissapear

         if(SSP1CON2bits.ACKSTAT==1)   //if acknoledge failed, stop transaction flag for a restart
         {
             ack_failed=1; // set a volatile char, will this be better THAN VOLATILE BOOL ?
             SSP1CON2bits.PEN = 1;// setting stop bit

         }
             else if(count<7){
             SSP1BUF = move_array[count]; // write new move into buffer if under 4
             count++; // prepare next move for buffer
             }

             else {  // if over 4 reset count, stop transaction
                 count=0; // reset count, we have updated all 4 DAC s
                 SSP1CON2bits.PEN = 1;
             }

          IFS1bits.SSP1IF=0;// clear flag, we come back after 8 bit transmit if necessary
    }


int main() {


    User_Init();
    ssp1_Init();
    timer1_Init();


    while(1) // main loop
    {




    }
}// end

// *****************************************************************************/
void User_Init(void) {

    OSCCON=0b0001000110101110;
    CLKDIV=0x0000;

    ANSA=0b1111111111111100; // RAO should be my DAC1 ref+ , RA1 A/D input, rest all digital
    TRISA= 0b0000000000000111; // all should be digital output exept RA0 and RA1
    LATA = 0b0000000000000000;  //initialize all to 0

    ANSB=  0b0010111111111111; // RB15 should be DAC2 ref+, RB14  DAC2OUT, RB12 DAC1OUT, rest all digital
    TRISB= 0b1101001100000100;// all digital output exept RB15, RB14 and RB12, RB2 is digital input for UART RX1, RB8 and RB9 are Input for I2C
    LATB = 0b0000000000000000; //initialize all to 0

 }
//**************************************
void ssp1_Init(void) {

    //SSP1STAT
    SSP1STATbits.SMP = 1;       //Slew Rate control. 1 = disabled (1Mhz).
    SSP1STATbits.CKE = 1;       //1=Enable SMBuss Specific inputs.
    //SSP1STATbits.D_NOT_A      //Flag, Slave mode Data/Address indicator.
    //SSP1STATbits.P            //Flag, 1 = Stop bit last detected.
    //SSP1STATbits.S            //Flag, 1 = Start bit last detected.
    //SSP1STATbits.R_NOT_W      //Master, 1 = TX in progress, TX not in prog.
    //SSP1STATbits.UA           //Update address, 10 bit slave mode only.
    SSP1STATbits.BF =0;          //Flag, 1 = Buffer full, 0 = Buffer empty.
     //Some alternate name for bits above.
    //SSP1STATbits.R_W          //1
    //SSP1STATbits.D_A          //1
    //SSP1STATbits.I2C_READ     //1
    //SSP1STATbits.I2C_START    //1
    //SSP1STATbits.I2C_STOP     //1
    //SSP1STATbits.I2C_DAT      //1

     //SSP1CON2
    SSP1CON2bits.GCEN = 0;      //General Call Interrupt enable.
    SSP1CON2bits.ACKSTAT = 0;   //Ack Status bit (Master TX mode only)
    SSP1CON2bits.ACKDT = 0;     //Ack Data bit   (Master Rx mode only)
    SSP1CON2bits.ACKEN = 0;     //Ack Sequence Enable (Master mode only)
    SSP1CON2bits.RCEN = 0;      //Receive Enable bit (Master Rx mode only)
    SSP1CON2bits.PEN = 0;       //Stop condition Enable (Master mode only)
    SSP1CON2bits.RSEN = 0;      //Repeated Start Enable (Master mode only)
    SSP1CON2bits.SEN = 0;       //Start Condition Enable.

    //SSP1CON3
    SSP1CON3bits.ACKTIM = 0;    //Ack Time Status bit.
    SSP1CON3bits.PCIE = 0;      //Stop condition Interrupt Enable.
    SSP1CON3bits.SCIE = 1;      //Start condition Interrupt Enable.
    SSP1CON3bits.BOEN = 0;      //Buffer overwrite enable.
    SSP1CON3bits.SDAHT = 1;     //SDA Hold time (1 = 300nS, 0= 100nS)
    SSP1CON3bits.SBCDE = 0;     //Slave Buss Colision detect (Slave mode)
    SSP1CON3bits.AHEN = 0;      //Address hold (Slave mode)
    SSP1CON3bits.DHEN = 0;      //Data hold (Slave mode)
     SSP1MSK = 0;                //Slave Address Mask register.

    SSP1ADD=15; // Formula for I2C clock = Fosc/( 2*(SSPxADD+1)) , so if I want clock 1 Mhz I put 15, since 32Mhz/(2*(15+1))=1Mhz

    //SSP1CON1
    SSP1CON1bits.WCOL = 0;      //Write Collision detect.
    SSP1CON1bits.SSPOV = 0;     //Receive overflow indicator, unused in master mode
    SSP1CON1bits.CKP = 0;       //1 = SCK Release, unused in master mode
    SSP1CON1bits.SSPM = 8;      //Master Synchronous Serial Port Mode.
                                //15 = I2C Slve, 10-bit Interrupts
                                //14 = I2C Slve, 7-bit Interrupts
                                //11 = I2C Firmware Master mode
                                //8  = I2C Mstr, Clk = FOSC/(2*([SSPxADD]+1))
                                //7  = I2C Slve, 10-bit addressing
                                //6  = I2C Slve, 7-bit addressing
    SSP1CON1bits.SSPEN = 1;     //Enables MSSP Port. 1 = Enable.

    //INTERRUPT INITIALISATION SFR
    //I2C INTERRUPT CONFIGS
    IEC1bits.SSP1IE=1; // I2C event enable bit
    IFS1bits.SSP1IF=0; // clear I2C event interrupt flag bit
    IPC4bits.SSP1IP=4; // Interrupt priority , bits 0 to 2 are 100 , 000 is 0 disabled , 111 is max priority 7
 }
//**********************************************************************************************************
void timer1_Init(void) {
    //INTERRUPT INITIALISATION SFR /////////////////////////////////////////////
    //TIMER 1 INTERRUPT CONFIGS
    IFS0bits.T1IF=0;
    IEC0bits.T1IE=1;
    IPC0bits.T1IP=4;
    T1CON=0b1000001100100000;
    PR1=12500;

 }
//**********************************************************************************************************
//**********************************************************************************************************************************************************************************************************